# Python imports
import zoneinfo

# Django imports
from django_filters.rest_framework import DjangoFilterBackend

# Third-party imports
from rest_framework import status
from rest_framework.exceptions import APIException
from rest_framework.filters import SearchFilter
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.settings import api_settings
from rest_framework.views import APIView
from rest_framework.viewsets import ModelViewSet

from django.conf import settings
from django.utils import timezone


class TimezoneMixin:
    """
    Mixin to handle timezone activation based on the authenticated user's settings.

    This mixin ensures that all requests are processed with the appropriate timezone
    set according to the user's preference. If the user is not authenticated,
    it deactivates the timezone settings.
    """

    def initial(self, request, *args, **kwargs):
        """
        Overrides the default `initial` method to activate or deactivate the timezone.

        If the request comes from an authenticated user, their specified timezone is activated.
        Otherwise, timezone settings are deactivated.

        Args:
            request (Request): The incoming request.
        """
        super().initial(request, *args, **kwargs)
        if request.user.is_authenticated:
            timezone.activate(zoneinfo.ZoneInfo(request.user.user_timezone))
        else:
            timezone.deactivate()


class PaginationMixin:
    @property
    def paginator(self):
        """
        The paginator instance associated with the view, or `None`.
        """
        if not hasattr(self, "_paginator"):
            if self.pagination_class is None:
                self._paginator = None
            else:
                self._paginator = self.pagination_class()
        return self._paginator

    def paginate_queryset(self, queryset):
        """
        Return a single page of results, or `None` if pagination
        is disabled.
        """
        if self.paginator is None:
            return queryset
        return self.paginator.paginate_queryset(queryset, self.request, view=self)

    def get_paginated_response(self, data):
        """
        Return a paginated style `Response` object for the given
        output data.
        """
        if self.paginator is None:
            return Response(data)
        return self.paginator.get_paginated_response(data)


class BaseViewSet(TimezoneMixin, PaginationMixin, ModelViewSet):
    model = None
    permission_classes = [IsAuthenticated]
    filter_backends = (DjangoFilterBackend, SearchFilter)
    filterset_fields = []
    search_fields = []

    def get_queryset(self):
        """
        Retrieves the queryset for the view.

        Returns:
            QuerySet: The queryset associated with the view's model.

        Raises:
            APIException: If the queryset retrieval fails, returns a 400 error.
        """
        try:
            return self.queryset or self.model.objects.all()
        except Exception as e:
            raise APIException("Please check the view", status.HTTP_400_BAD_REQUEST)

    def filter_queryset(self, queryset):
        """
        Applies filtering to the given queryset using the configured filter backends.

        Args:
            queryset (QuerySet): The original queryset.

        Returns:
            QuerySet: The filtered queryset.
        """
        for backend in list(self.filter_backends):
            queryset = backend().filter_queryset(self.request, queryset, self)
        return queryset

    def dispatch(self, request, *args, **kwargs):
        """
        Handles the request dispatching, including logging query counts in debug mode.

        If an exception occurs, it is caught and handled appropriately.

        Args:
            request (Request): The incoming request.

        Returns:
            Response: The response generated by the view.
        """
        try:
            response = super().dispatch(request, *args, **kwargs)
            if settings.DEBUG:
                from django.db import connection

                print(
                    f"{request.method} - {request.get_full_path()} of Queries: {len(connection.queries)}"
                )
            return response
        except Exception as exc:
            response = self.handle_exception(exc)
            return exc


class BaseAPIView(TimezoneMixin, APIView):
    """
    Base API view that provides default configurations for API views.

    This class extends `APIView` and includes:
    - Authentication enforcement (only authenticated users can access).
    - Filtering support using DjangoFilterBackend and SearchFilter.
    - Automatic timezone handling via `TimezoneMixin`.
    - Enhanced exception handling.

    """

    permission_classes = [IsAuthenticated]
    filter_backends = (DjangoFilterBackend, SearchFilter)
    filterset_fields = []
    search_fields = []

    def filter_queryset(self, queryset):
        """
        Applies filtering to the given queryset using the configured filter backends.

        Args:
            queryset (QuerySet): The original queryset.

        Returns:
            QuerySet: The filtered queryset.
        """
        for backend in list(self.filter_backends):
            queryset = backend().filter_queryset(self.request, queryset, self)
        return queryset

    def dispatch(self, request, *args, **kwargs):
        """
        Handles the request dispatching, including logging query counts in debug mode.

        If an exception occurs, it is caught and handled appropriately.

        Args:
            request (Request): The incoming request.

        Returns:
            Response: The response generated by the view.
        """
        try:
            response = super().dispatch(request, *args, **kwargs)
            if settings.DEBUG:
                from django.db import connection

                print(
                    f"{request.method} - {request.get_full_path()} of Queries: {len(connection.queries)}"
                )
            return response
        except Exception as exc:
            response = self.handle_exception(exc)
            return exc
